import{createRequire as e}from"module";if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=new URL(".",import.meta.url).pathname.slice(import.meta.url.match(/^file:\/\/\/\w:/)?1:0,-1)+"/";var t={};const s=e(import.meta.url)("node:process");const r=e(import.meta.url)("node:util");const o=e(import.meta.url)("node:path");const n=e(import.meta.url)("node:url");const c=e(import.meta.url)("node:child_process");const i=o.dirname((0,n.fileURLToPath)(import.meta.url));const p=1e3*1e3*10;const a=(0,r.promisify)(c.execFile);const windows=async()=>{let e;switch(s.arch){case"x64":e="fastlist-0.3.0-x64.exe";break;case"ia32":e="fastlist-0.3.0-x86.exe";break;default:throw new Error(`Unsupported architecture: ${s.arch}`)}const t=o.join(i,"vendor",e);const{stdout:r}=await a(t,{maxBuffer:p,windowsHide:true});return r.trim().split("\r\n").map((e=>e.split("\t"))).map((([e,t,s])=>({pid:Number.parseInt(e,10),ppid:Number.parseInt(t,10),name:s})))};const nonWindowsMultipleCalls=async(e={})=>{const t=(e.all===false?"":"a")+"wwxo";const s={};await Promise.all(["comm","args","ppid","uid","%cpu","%mem"].map((async e=>{const{stdout:r}=await a("ps",[t,`pid,${e}`],{maxBuffer:p});for(let t of r.trim().split("\n").slice(1)){t=t.trim();const[r]=t.split(" ",1);const o=t.slice(r.length+1).trim();if(s[r]===undefined){s[r]={}}s[r][e]=o}})));return Object.entries(s).filter((([,e])=>e.comm&&e.args&&e.ppid&&e.uid&&e["%cpu"]&&e["%mem"])).map((([e,t])=>({pid:Number.parseInt(e,10),name:o.basename(t.comm),cmd:t.args,ppid:Number.parseInt(t.ppid,10),uid:Number.parseInt(t.uid,10),cpu:Number.parseFloat(t["%cpu"]),memory:Number.parseFloat(t["%mem"])})))};const m="ps output parsing failed";const l=/^[ \t]*(?<pid>\d+)[ \t]+(?<ppid>\d+)[ \t]+(?<uid>[-\d]+)[ \t]+(?<cpu>\d+\.\d+)[ \t]+(?<memory>\d+\.\d+)[ \t]+(?<comm>.*)?/;const nonWindowsCall=async(e={})=>{const t=e.all===false?"wwxo":"awwxo";const s=[a("ps",[t,"pid,ppid,uid,%cpu,%mem,comm"],{maxBuffer:p}),a("ps",[t,"pid,args"],{maxBuffer:p})];const[r,n]=(await Promise.all(s)).map((({stdout:e})=>e.trim().split("\n")));const c=new Set(s.map((e=>e.child.pid)));r.shift();n.shift();const i={};for(const e of n){const[t,s]=e.trim().split(" ");i[t]=s.join(" ")}const d=r.map((e=>{const t=l.exec(e);if(t===null){throw new Error(m)}const{pid:s,ppid:r,uid:n,cpu:c,memory:p,comm:a}=t.groups;const d={pid:Number.parseInt(s,10),ppid:Number.parseInt(r,10),uid:Number.parseInt(n,10),cpu:Number.parseFloat(c),memory:Number.parseFloat(p),name:o.basename(a),cmd:i[s]};return d})).filter((e=>!c.has(e.pid)));return d};const nonWindows=async(e={})=>{try{return await nonWindowsCall(e)}catch{return nonWindowsMultipleCalls(e)}};const d=s.platform==="win32"?windows:nonWindows;const u=d;const f=process.env.GITHUB_WORKSPACE||"";const terminateOrphans=async()=>{const e=await u();const t=e.filter((e=>e.cmd?.includes("/chrome/chrome")));const s=e.filter((e=>e.cmd?.includes("/Cypress/Cypress")&&e.cmd.includes("--run-project")));const r=s.filter((e=>e.cmd?.includes(`--run-project ${f}`)));console.log("Chrome processes:",t.length);console.log("Cypress processes:",s.length);console.log("Cypress orphans:",r.length);r.forEach((e=>{t.filter((t=>t.cmd?.includes(`run-${e.pid}`))).forEach((e=>{console.log(`Killing Chrome process ${e.pid} ${e.cmd}\n`);process.kill(e.pid,"SIGKILL")}));console.log(`Killing Cypress process ${e.pid} ${e.cmd}\n`);process.kill(e.pid,"SIGKILL")}))};terminateOrphans().then();